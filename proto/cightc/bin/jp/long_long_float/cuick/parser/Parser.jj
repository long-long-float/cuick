options {
	STATIC = false;
	DEBUG_PARSER = true;
	UNICODE_INPUT = true;
}

PARSER_BEGIN(Parser)
public class Parser {
	protected Location location(Token t) {	   return new Location(sourceName, t);
	}
}
PARSER_END(Parser)

SPECIAL_TOKEN: { <SPACES: ([" ", "\t", "\n", "\r", "\f"])+> }

MORE: { <"/*"> : IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> MORE: { <~[]> }
<IN_BLOCK_COMMENT> SPECIAL_TOKEN: {<BLOCK_COMMENT: "*/"> : DEFAULT }

SPECIAL_TOKEN: {
	<LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?>
}

TOKEN: {
    <ASM : "asm">
  | <AUTO : "auto">
  | <BOOL : "bool">
  | <BREAK : "break">
  | <CASE : "case">
  | <CATCH : "catch">
  | <CHAR : "char">
  | <CLASS : "class">
  | <CONST : "const">
  | <CONST_CAST : "const_cast">
  | <CONTINUE : "continue">
  | <DEFAULT_ : "default">
  | <DELETE : "delete">
  | <DO : "do">
  | <DOUBLE : "double">
  | <DYNAMIC_CAST : "dynamic_cast">
  | <ELSE : "else">
  | <ENUM : "enum">
  | <EXPLICIT : "explicit">
  | <EXPORT : "export">
  | <EXTERN : "extern">
  | <FALSE : "false">
  | <FLOAT : "float">
  | <FOR : "for">
  | <FRIEND : "friend">
  | <GOTO : "goto">
  | <IF : "if">
  | <INLINE : "inline">
  | <INT : "int">
  //!
  | <LAST : "last">
  | <LONG : "long">
  | <MUTABLE : "mutable">
  | <NAMESPACE : "namespace">
  | <NEW : "new">
  | <OPERATOR : "operator">
  | <PRIVATE : "private">
  | <PROTECTED : "protected">
  | <PUBLIC : "public">
  | <REGISTER : "register">
  | <REINTERPRET_CAST : "reinterpret_cast">
  | <RETURN : "return">
  | <SHORT : "short">
  | <SIGNED : "signed">
  | <SIZEOF : "sizeof">
  | <STATIC : "static">
  | <STATIC_CAST : "static_cast">
  | <STRUCT : "struct">
  | <SWITCH : "switch">
  | <TEMPLATE : "template">
  | <THIS : "this">
  | <THROW : "throw">
  | <TRUE : "true">
  | <TRY : "try">
  | <TYPEDEF : "typedef">
  | <TYPEID : "typeid">
  | <TYPENAME : "typename">
  | <UNION : "union">
  | <UNSIGNED : "unsigned">
  | <USING : "using">
  | <VIRTUAL : "virtual">
  | <VOID : "void">
  | <VOLATILE : "volatile">
  | <WCHAR_T : "wchar_t">
  | <WHILE : "while">
  | <DOLLAR : "$">
  | <EXTEND : "extend">
}

TOKEN: {
	<IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}

//数値
TOKEN: {
	<INTEGER: ["1"-"9"](["0"-"9"])* ("U")? ("L")?
		| "0" ["x", "X"](["0"-"9", "a"-"f", "A"-"F"])+ ("U")? ("L")?
		| "0" (["0"-"7"])* ("U")? ("L")?
		| "0" (["b", "B"]) (["0"-"1"])+ ("U")? ("L")?
		>
}

MORE: { <"'"> : IN_CHARACTER }
<IN_CHARACTER> MORE: {
      <~["'", "\\", "\n", "\r"]> : CHARACTER_TERM
    | <"\\" (["0"-"7"]){3}> : CHARACTER_TERM
    | <"\\" ~[]> : CHARACTER_TERM
}
<CHARACTER_TERM> TOKEN: { <CHARACTER: "'"> : DEFAULT }

MORE: { <"\""> : IN_STRING }
<IN_STRING> MORE: {
      <(~["\"", "\\", "\n", "\r"])+>
    | <"\\" (["0"-"7"]){3}>
    | <"\\" ~[]>
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT }

MORE: { <"`"> : IN_BUILT_IN_CODE }
<IN_BUILT_IN_CODE> MORE: {
      <(~["`"])>
    | <"\\`" >
}
<IN_BUILT_IN_CODE> TOKEN: { <BUILT_IN_CODE: "`"> : DEFAULT }

TOKEN: {
    <ONE_LINE: ("\n" | "\r\n" | "\r") (~["\n", "\r"])* ("\n" | "\r\n" | "\r")>
}

//文法

//ソース全体
AST comlilation_unit():
{
    Token t;

    Declarations decls = new Declarations();

    Function func;
    List<Variable> vars;
    TypedefNode typedef;
    AtCommandNode at_command;
    StmtNode stmt;
}
{
    {
        t = getToken(1);
    }
    (
        LOOKAHEAD([name()] type_with_suffix() name() "(")
        func=deffun() { decls.funcs.add(func); }
    |   LOOKAHEAD([name()] type_with_suffix() type_with_suffix() ".")
        func=def_extendfun() { decls.funcs.add(func); }
    |   LOOKAHEAD(type()) vars=defvars() { decls.vars.addAll(vars); }
    |   typedef=typedef() { decls.typedefs.add(typedef); }
    |   at_command=at_command() { decls.atCommands.add(at_command); }
    |   stmt=stmt() { decls.stmts.add(stmt); }
    )* <EOF>
    {
        return new AST(location(t), decls);
    }
}

//変数宣言
List<Variable> defvars():
{
    List<Variable> defs = new ArrayList<Variable>();
    Type type;
    String name;
    ExprNode init = null;
}
{
    //storage(staticなど)は無し
    type=type() ["&"] ("*")* name=name() ["[" [expr()] "]"] ["=" init=expr()]
        {
            defs.add(new Variable(new TypeNode(type), name, init));
            init = null;
        }
    (","  ["&"] ("*")* name=name() ["[" [expr()] "]"] ["=" init=expr()]
        {
            defs.add(new Variable(new TypeNode(type), name, init));
            init = null;
        }
    )* ";"
        {
            return defs;
        }
}

Function deffun():
{
    //String modif = null;
    Type ret;
    String n;
    Params ps;
    BlockNode body;
}
{
    ret=type_with_suffix() n=name() "(" ps=params() ")" body=block()
        {
            Type type = new FunctionType(ret, ps.parametersType());
            return new Function(new TypeNode(type), n, ps, body);
        }
}

Function def_extendfun():
{
    Token t;
    Type ret;
    Type receiver;
    String n;
    Params ps;
    BlockNode body;
}
{
    t=<EXTEND> ret=type_with_suffix() receiver=type_with_suffix() "." n=name() "(" ps=params() ")" body=block()
        {
            ps.addParamFront(new Parameter(new TypeNode(receiver), "this"));
            Type type = new FunctionType(ret, ps.parametersType());
            return new Function(location(t), new TypeNode(type), n, ps, body);
        }
}

Params params():
{
    List<Parameter> params = new ArrayList<Parameter>();
    Parameter param, param1;
}
{
    param1=param() { params.add(param1); }
    ("," param=param() { params.add(param); } )*
        {
            return new Params(param1.location(), params);
        }
}

Parameter param():
{
    Type t;
    String n;
}
{
    t=type() ["&"] ("*")* n=name() ["[" [expr()] "]"] { return new Parameter(new TypeNode(t), n); }
}

BlockNode block():
{
    Token t;
    List<Variable> vars, varsAll = new ArrayList<Variable>();
    StmtNode stmt;
    List<StmtNode> stmts = new ArrayList<StmtNode>();
}
{
    t="{"
    (
        LOOKAHEAD(type()) vars=defvars() { varsAll.addAll(vars); }
    |   stmt=stmt() { stmts.add(stmt); }
    )*
        {
            return new BlockNode(location(t), varsAll, stmts);
        }
    "}"
}

TypedefNode typedef():
{
    Token t;
    String realname, newname;
    ExprNode expr = null;
}
{
    t=<TYPEDEF>
        realname=name() ("*" { realname += '*'; })* ["&" { realname += '&'; }]
        newname=name() ["[" expr=expr() "]"] ";"
        {
            //addType(newname.image);
            return new TypedefNode(location(t), realname, newname, expr);
        }
}

/*
何もついてない素の型
int
vector<int, int>
$T
*/
Type type():
{
    Token t;
	String name;
	
    Type type;
    List<Type> templ_types = null;
    //ParamTypeRefs params;
}
{
    t=<DOLLAR> name=name()
  {
    return new FunctionTemplateType(name, location(t));
  }
  | type=type_base() [templ_types=templ_types()]
  {
    return new TemplateType(templ_types, type);
  }
}

/*
*や&が付いた型
int*
int&
$T*
*/
Type type_with_suffix():
{
  Type type;
}
{
  type=type() ("*" { type = new PointerType(type); })*
    ["&" { type = new ReferenceType(type); }]
  {    return type;
  }
}

Type type_base():
{
    Token t, t1, t2;
    List<String> types = new ArrayList<String>();
    String typename;
}
{
/*      t=<VOID>          { return new VoidType(location(t)); }
    | t=<CHAR>          { return IntegerType.charType(location(t)); }
    | t=<SHORT>         { return IntegerType.shortType(location(t)); }
    | t=<INT>           { return IntegerType.intType(location(t)); }
    | t=<LONG>          { return IntegerType.longType(location(t)); }
    | LOOKAHEAD(2) t=<UNSIGNED> <CHAR>
        { return IntegerType.ucharType(location(t)); }
    | LOOKAHEAD(2) t=<UNSIGNED> <SHORT>
        { return IntegerType.ushortType(location(t)); }
    | LOOKAHEAD(2) t=<UNSIGNED> <INT>
        { return IntegerType.uintType(location(t)); }
    | t=<UNSIGNED> <LONG>
        { return IntegerType.ulongType(location(t)); }
    | t=<STRUCT> name=<IDENTIFIER>
        { return new StructType(location(t), name.image); }
    | t=<UNION> name=<IDENTIFIER>
        { return new UnionType(location(t), name.image); }
    |  LOOKAHEAD({isType(getToken(1).image)}) name=<IDENTIFIER>
        { return new UserType(location(nameType.image)); }*/
    t1=basic_type() { types.add(t1.image); } ( t2=basic_type() { types.add(t2.image); } )*
        { return new BasicType(types, location(t1)); }
    | t=<IDENTIFIER>        { return new NamedType(t.image, location(t)); }
}

Token basic_type():{
  Token t;}
{
  (t=<CHAR> | t=<SHORT> | t=<INT> | t=<LONG> | t=<UNSIGNED> | t=<FLOAT> | t=<DOUBLE>)  {    return t;
  }}

StmtNode stmt():
{
    StmtNode n = null;
    ExprNode e = null;
}
{
    (
        ";" //null statement
    |   e=expr() ";" { n = new ExprStmtNode(e.location(), e); }
    |   n=block()
    |   n=if_stmt()
    |   n=while_stmt()
    |   n=dowhile_stmt()
    |   LOOKAHEAD(<FOR> expr() ";") n=for_stmt()
    |   n=foreach_stmt()
    |   n=switch_stmt()
    |   n=break_stmt()
    |   n=continue_stmt()
    |   n=return_stmt()
    )
        {
            return n;
        }
}

IfNode if_stmt():
{
    Token t;
    ExprNode cond;
    StmtNode thenBody, elseBody = null;
}
{
    t=<IF> "(" cond=expr() ")" thenBody=stmt()
        [ LOOKAHEAD(1) <ELSE> elseBody=stmt() ]
        {
            return new IfNode(location(t), cond, thenBody, elseBody);
        }
}

WhileNode while_stmt():
{
    Token t;
    ExprNode cond;
    StmtNode body;
}
{
    t=<WHILE> "(" cond=expr() ")" body=stmt()
        {
            return new WhileNode(location(t), cond, body);
        }
}

DoWhileNode dowhile_stmt():
{
    Token t;
    ExprNode cond;
    StmtNode body;
}
{
    t=<DO> body=stmt() <WHILE> "(" cond=expr() ")" ";"
        {
            return new DoWhileNode(location(t), body, cond);
        }
}

ForNode for_stmt():
{
    Token t;
    ExprNode init = null, cond = null, incr = null;
    StmtNode body;
}
{
    t=<FOR> "(" [init=expr()] ";" [cond=expr()] ";" [incr=expr()] ")" body=stmt()
        {
            return new ForNode(location(t), init, cond, incr, body);
        }
}

ForEachNode foreach_stmt():
{
    Token t;

    Type var_type;
    String var_name;
    List<Pair<Type, String>> vars = new ArrayList<Pair<Type, String>>();

    boolean fore = true;

    Enumerable enume;
    List<Enumerable> enumes = new ArrayList<Enumerable>();

    StmtNode body, lastBody = null;
}
{
    t=<FOR> "("
        var_type=type() var_name=name() { vars.add(new Pair<Type, String>(var_type, var_name)); }
        ("," var_type=type() var_name=name() { vars.add(new Pair<Type, String>(var_type, var_name)); })*
        ":" [">" | "<" { fore = true; }]
        enume=enumerable() { enumes.add(enume); }
        ")" body=stmt()
        [ LOOKAHEAD(1) <LAST> lastBody=stmt() ]
        {
            return new ForEachNode(location(t), vars, fore, enumes, body, lastBody);
        }
}

Enumerable enumerable():
{
    ExprNode expr;
    RangeNode range;

    List<ExprNode> exprs = new ArrayList<ExprNode>();   
}
{
    //range
    LOOKAHEAD(expr() (".." | "...")) range=range()
        {
            return new RangeEnumerable(range);
        }
    //変数(ポインタ、配列 tuple 整数 std::map container込み)の集合
    |  expr=expr() { exprs.add(expr); } ("," expr=expr() { exprs.add(expr); })*
        {
            return new VariableSetEnumerable(exprs);
        }
}


SwitchNode switch_stmt():
{
    Token t;
    ExprNode cond;
    List<CaseNode> bodies;
}
{
    t=<SWITCH> "(" cond=expr() ")" "{" bodies=case_clauses() "}"
        {
            return new SwitchNode(location(t), cond, bodies);
        }
}

List<CaseNode> case_clauses():
{
    List<CaseNode> clauses = new ArrayList<CaseNode>();
    CaseNode n;
}
{
    (n=case_clause() { clauses.add(n); })*
            [n=default_clause() { clauses.add(n); }]
        {
            return clauses;
        }
}

CaseNode case_clause():
{
    List<ExprNode> values;
    BlockNode body;
}
{
    values=cases() body=case_body()
        {
            return new CaseNode(body.location(), values, body);
        }
}

List<ExprNode> cases():
{
    List<ExprNode> values = new ArrayList<ExprNode>();
    ExprNode n;
}
{
    (<CASE> n=primary() ":" { values.add(n); })+
        {
            return values;
        }
}

CaseNode default_clause():
{ BlockNode body; }
{
    <DEFAULT_> ":" body=case_body()
        {
            return new CaseNode(body.location(), new ArrayList<ExprNode>(), body);
        }
}

BlockNode case_body():
{
    LinkedList<StmtNode> stmts = new LinkedList<StmtNode>();
    StmtNode s;
}
{
    (s=stmt() { if (s != null) stmts.add(s); })+
        {
            /*
            fall through
            // last stmt of case clause must be break stmt.
            if (! (stmts.getLast() instanceof BreakNode)) {
                throw new ParseException(
                  "missing break statement at the last of case clause");
            }
                */
            return new BlockNode(stmts.get(0).location(),
                                 new ArrayList<Variable>(),
                                 stmts);
        }
}
BreakNode break_stmt():
{ Token t; }
{
    t=<BREAK> ";" { return new BreakNode(location(t)); }
}

ContinueNode continue_stmt():
{ Token t; }
{
    t=<CONTINUE> ";" { return new ContinueNode(location(t)); }
}

ReturnNode return_stmt():
{
    Token t;
    ExprNode expr;
}
{
      LOOKAHEAD(2) t=<RETURN> ";" { return new ReturnNode(location(t), null); }
    | t=<RETURN> expr=expr() ";"  { return new ReturnNode(location(t), expr); }
}

MultiplexAssignNode multiplex_assign():
{
    ExprNode expr;
    List<ExprNode> lhses = new ArrayList<ExprNode>();
    List<ExprNode> rhses = new ArrayList<ExprNode>();
}
{
    expr=term(){ lhses.add(expr); }
        ("," expr=term(){ lhses.add(expr); } )+
        "=" expr=term(){ rhses.add(expr); }
        ("," expr=term(){ rhses.add(expr); })* ";"
        {
            return new MultiplexAssignNode(lhses, rhses);
        }
}

ExprNode expr():
{
    ExprNode lhs, rhs, expr;
    String op;
    ExprNode n;
}
{
      LOOKAHEAD(term() "=")
      lhs=term() "=" rhs=expr()
        {
            return new AssignNode(lhs, rhs);
        }
    | LOOKAHEAD(term() ",") n=multiplex_assign()
        {            return n;
        }
    | LOOKAHEAD(term() opassign_op())
      lhs=term() op=opassign_op() rhs=expr()
        {
            return new OpAssignNode(lhs, op, rhs);
        }
    | expr=expr10()
        {
            return expr;
        }
}

String opassign_op(): {}
{
    ( "+="  { return "+"; }
    | "-="  { return "-"; }
    | "*="  { return "*"; }
    | "/="  { return "/"; }
    | "%="  { return "%"; }
    | "&="  { return "&"; }
    | "|="  { return "|"; }
    | "^="  { return "^"; }
    | "<<=" { return "<<"; }
    | ">>=" { return ">>"; }
    | "**=" { return "**"; }
    )
}

ExprNode expr10():
{ ExprNode c, t, e; }
{
    c=expr9() ["?" t=expr() ":" e=expr10()
                    { return new CondExprNode(c, t, e); }]
        {
            return c;
        }
}

ExprNode expr9():
{ ExprNode l, r; }
{
    l=expr8() ("||" r=expr8() { l = new BinaryOpNode(l, "||", r); })*
        {
            return l;
        }
}

ExprNode expr8():
{ ExprNode l, r; }
{
    l=expr7() ("&&" r=expr7() { l = new BinaryOpNode(l, "&&", r); })*
        {
            return l;
        }
}

ExprNode expr7():
{ ExprNode l, r; }
{
    l=expr6() ( ">"  r=expr6() { l = new BinaryOpNode(l, ">", r); }
              | "<"  r=expr6() { l = new BinaryOpNode(l, "<", r); }
              | ">=" r=expr6() { l = new BinaryOpNode(l, ">=", r); }
              | "<=" r=expr6() { l = new BinaryOpNode(l, "<=", r); }
              | "==" r=expr6() { l = new BinaryOpNode(l, "==", r); }
              | "!=" r=expr6() { l = new BinaryOpNode(l, "!=", r); } )*
        {
            return l;
        }
}

ExprNode expr6():
{ ExprNode l, r; }
{
    l=expr5() ("|" r=expr5() { l = new BinaryOpNode(l, "|", r); })*
        {
            return l;
        }
}

ExprNode expr5():
{ ExprNode l, r; }
{
    l=expr4() ("^" r=expr4() { l = new BinaryOpNode(l, "^", r); })*
        {
            return l;
        }
}

ExprNode expr4():
{ ExprNode l, r; }
{
    l=expr3() ("&" r=expr3() { l = new BinaryOpNode(l, "&", r); })//*
        {
            return l;
        }
}

ExprNode expr3():
{ ExprNode l, r; }
{
    l=expr2() ( ">>" r=expr2() { l = new BinaryOpNode(l, ">>", r); }
              | "<<" r=expr2() { l = new BinaryOpNode(l, "<<", r); }
              )*
        {
            return l;
        }
}

ExprNode expr2():
{ ExprNode l, r; }
{
    l=expr1() ( "+" r=expr1() { l = new BinaryOpNode(l, "+", r); }
              | "-" r=expr1() { l = new BinaryOpNode(l, "-", r); }
              )*
        {
            return l;
        }
}

ExprNode expr1():
{ ExprNode l, r; }
{
    l=term() ( "*" r=term() { l = new BinaryOpNode(l, "*", r); }
             | "/" r=term() { l = new BinaryOpNode(l, "/", r); }
             | "%" r=term() { l = new BinaryOpNode(l, "%", r); }
             )*
        {
            return l;
        }
}

ExprNode term():
{
    Type t;
    ExprNode n;
}
{
      LOOKAHEAD("(" type())
      "(" t=type() ("*")* ")" n=term()     { return new CastNode(t, n); }
    | n=unary()                     { return n; }
}

ExprNode unary():
{
    ExprNode n;
    Type t;
}
{
      "++" n=unary()    { return new PrefixOpNode("++", n); }
    | "--" n=unary()    { return new PrefixOpNode("--", n); }
    | "+" n=term()      { return new UnaryOpNode("+", n); }
    | "-" n=term()      { return new UnaryOpNode("-", n); }
    | "!" n=term()      { return new UnaryOpNode("!", n); }
    | "~" n=term()      { return new UnaryOpNode("~", n); }
    | "*" n=term()      { return new UnaryOpNode("*", n); }//{ return new DereferenceNode(n); }
    | "&" n=term()      { return new UnaryOpNode("&", n); }//{ return new AddressNode(n); }
    | LOOKAHEAD(3) <SIZEOF> "(" t=type() ")"
        {
            return new SizeofTypeNode(new TypeNode(t)/*, size_t()*/);
        }
    | <SIZEOF> n=unary()
        {
            return new SizeofExprNode(n/*, size_t()*/);
        }
    | n=postfix()       { return n; }
}

ExprNode postfix():
{
    ExprNode expr, idx;
    String memb;
    //List<TypeNode> types = null;
    List<ExprNode> args;
    List<Type> templ_types = null;
}
{
    expr=primary()
    ( "++"                  { expr = new SuffixOpNode("++", expr); }
    | "--"                  { expr = new SuffixOpNode("--", expr); }
    | "[" idx=expr() "]"    { expr = new ArefNode(expr, idx); }
    | "." memb=name()       { expr = new MemberNode(expr, memb); }
    | "::" memb=name()      { expr = new StaticMemberNode(expr, memb); }
    | "->" memb=name()      { expr = new PtrMemberNode(expr, memb); }
    | [templ_types=templ_types()] "(" args=args() ")"   { expr = new FuncallNode(expr, templ_types, args); }
    )*
        {
            return expr;
        }
}

List<Type> templ_types():
{
    List<Type> types = new ArrayList<Type>();
    Type type;
}
{
    "[[" type=type_with_suffix() { types.add(type); }
        ("," type=type_with_suffix(){ types.add(type); } )+ "]]"
        {
            return types;
        }
}

String name():
{
    Token t;
}
{
    t=<IDENTIFIER> { return t.image; }
}

List<ExprNode> args():
{
    List<ExprNode> args = new ArrayList<ExprNode>();
    ExprNode arg;
}
{
    [ arg=expr() { args.add(arg); }
        ("," arg=expr() { args.add(arg); })* ]
            {
                return args;
            }
}

ExprNode primary():
{
    Token t;
    ExprNode n;
}
{
    t=<INTEGER>
        {
            //return integerNode(location(t), t.image);
            return new LiteralNode(location(t), new BasicType("int", location(t)), t.image); //TODO int以外のも作る
        }
    |   t=<CHARACTER>
        {
            //return new IntegerLiteralNode(location(t), IntegerType.charRef(), characterCode(t.image));
            return new LiteralNode(location(t), new BasicType("char", location(t)), t.image);
        }
    |   t=<STRING>
        {
            //return new StringLiteralNode(location(t), new PointerType(IntegerType.charRef()), stringValue(t.image));
            return new LiteralNode(location(t), new PointerType(new BasicType("char", location(t))), t.image);
        }
    /*|   r=range()
        {
            return r;
        }*/
    |   t=<IDENTIFIER>
        {
            return new VariableNode(location(t), t.image);
        }
    |   "(" n=expr() ")"
        {
            return n;
        }
}

RangeNode range():
{
    ExprNode lexpr, rexpr;
    String r;
}
{
    lexpr=expr() (".."  { r = ".."; } | "..." { r = "..."; } ) rexpr=expr()
        {
            return new RangeNode(lexpr, r, rexpr);
        }
}

//@命令
//TODO
AtCommandNode at_command():
{
    AtCommandNode atCommand;
}
{
    atCommand = at_input()
    |   atCommand = at_debug()
    |   atCommand = at_memo()
    |   atCommand = at_while()
    |   atCommand = at_test()
    {        return atCommand;
    }
}

AtInputNode at_input():
{
    Token t, name;
    List<AtInputAbstractVariableNode> vars = new ArrayList<AtInputAbstractVariableNode>();
    RangeNode range;
    ExprNode expr;
}
{
    t="@input" "{"
        (
	        LOOKAHEAD(<IDENTIFIER> "[") name=<IDENTIFIER> "["
	            (LOOKAHEAD(expr() ("..." | "..")) range=range() { vars.add(new AtInputArrayVariableNode(location(name), name.image, range)); }
	                | expr=expr() { vars.add(new AtInputArrayVariableNode(location(name), name.image, expr)); }
	            ) "]"
	    |   LOOKAHEAD(<IDENTIFIER> "!")
	        name=<IDENTIFIER> "!" { vars.add(new AtInputVariableNode(location(name), name.image, true)); }
        |   name=<IDENTIFIER> { vars.add(new AtInputVariableNode(location(name), name.image, false)); }
        )*
    "}"
    {        return new AtInputNode(location(t), vars);
    }
}

AtDebugNode at_debug():
{    Token t;
}
{    t="@debug"
    {        return new AtDebugNode(location(t));
    }
}

AtMemoNode at_memo():
{
    Token t;
    ExprNode hash, max = null;
    Function func;
}
{
    t="@memo" "(" hash=expr() ["," max=expr()] ")" func=deffun()
    {        return new AtMemoNode(location(t), hash, max, func);
    }
}

AtWhileNode at_while():
{
    Token t;
    ExprNode cond;
}
{
    t="@while" "(" cond=expr() ")"
    {        return new AtWhileNode(location(t), cond);
    }
}

AtTestNode at_test():
{    Token t, t2, line;
    List<Token> lines = new ArrayList<Token>();
    List<AtTestCase> inCases = new ArrayList<AtTestCase>();
    List<AtTestCase> outCases = new ArrayList<AtTestCase>();
}
{    t="@test" "{"
	    (
	        t2="in:" ( line=<ONE_LINE> { lines.add(line); } )+
	        {	           inCases.add(new AtTestCase(location(t2), lines));
	           lines = new ArrayList<Token>();
	        }
	        | t2="out:"  ( line=<ONE_LINE> { lines.add(line); } )+
            {
               outCases.add(new AtTestCase(location(t2), lines));
               lines = new ArrayList<Token>();
            }
         )
    "}"
    {        return new AtTestNode(location(t), inCases, outCases);
    }
}